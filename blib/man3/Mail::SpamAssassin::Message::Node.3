.\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Mail::SpamAssassin::Message::Node 3"
.TH Mail::SpamAssassin::Message::Node 3 "2011-06-07" "perl v5.18.1" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Mail::SpamAssassin::Message::Node \- decode, render, and make available MIME message parts
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This module will encapsulate an email message and allow access to
the various \s-1MIME\s0 message parts.
.SH "PUBLIC METHODS"
.IX Header "PUBLIC METHODS"
.IP "\fInew()\fR" 4
.IX Item "new()"
Generates an empty Node object and returns it.  Typically only called
by functions in Message.
.IP "\fIfind_parts()\fR" 4
.IX Item "find_parts()"
Used to search the tree for specific \s-1MIME\s0 parts.  An array of matching
Node objects (pointers into the tree) is returned.  The parameters that
can be passed in are (in order, all scalars):
.Sp
Regexp \- Used to match against each part's Content-Type header,
specifically the type and not the rest of the header.  ie: \*(L"Content-type:
text/html; encoding=quoted\-printable\*(R" has a type of \*(L"text/html\*(R".  If no
regexp is specified, \fIfind_parts()\fR will return an empty array.
.Sp
Only_leaves \- By default, \fIfind_parts()\fR will return any part that matches
the regexp, including multipart.  If you only want to see leaves of the
tree (ie: parts that aren't multipart), set this to true (1).
.Sp
Recursive \- By default, when \fIfind_parts()\fR finds a multipart which has
parts underneath it, it will recurse through all sub-children.  If set to 0,
only look at the part and any direct children of the part.
.IP "\fIheader()\fR" 4
.IX Item "header()"
Stores and retrieves headers from a specific \s-1MIME\s0 part.  The first
parameter is the header name.  If there is no other parameter, the header
is retrieved.  If there is a second parameter, the header is stored.
.Sp
Header names are case-insensitive and are stored in both raw and
decoded form.  Using \fIheader()\fR, only the decoded form is retrievable.
.Sp
For retrieval, if \fIheader()\fR is called in an array context, an array will
be returned with each header entry in a different element.  In a scalar
context, the last specific header is returned.
.Sp
ie: If 'Subject' is specified as the header, and there are 2 Subject
headers in a message, the last/bottom one in the message is returned in
scalar context or both are returned in array context.
.IP "\fIraw_header()\fR" 4
.IX Item "raw_header()"
Retrieves the raw version of headers from a specific \s-1MIME\s0 part.  The only
parameter is the header name.  Header names are case-insensitive.
.Sp
For retrieval, if \fIraw_header()\fR is called in an array context, an array
will be returned with each header entry in a different element.  In a
scalar context, the last specific header is returned.
.Sp
ie: If 'Subject' is specified as the header, and there are 2 Subject
headers in a message, the last/bottom one in the message is returned in
scalar context or both are returned in array context.
.IP "\fIadd_body_part()\fR" 4
.IX Item "add_body_part()"
Adds a Node child object to the current node object.
.IP "\fIis_leaf()\fR" 4
.IX Item "is_leaf()"
Returns true if the tree node in question is a leaf of the tree (ie:
has no children of its own).  Note: This function may return odd results
unless the message has been mime parsed via \fI_do_parse()\fR!
.IP "\fIraw()\fR" 4
.IX Item "raw()"
Return a reference to the the raw array.  Treat this as \s-1READ ONLY.\s0
.IP "\fIdecode()\fR" 4
.IX Item "decode()"
If necessary, decode the part text as base64 or quoted-printable.
The decoded text will be returned as a scalar string.  An optional length
parameter can be passed in which limits how much decoded data is returned.
If the scalar isn't needed, call with \*(L"0\*(R" as a parameter.
.IP "\fIrendered()\fR" 4
.IX Item "rendered()"
\&\fIrender_text()\fR takes the given text/* type \s-1MIME\s0 part, and attempts to
render it into a text scalar.  It will always render text/html, and will
use a heuristic to determine if other text/* parts should be considered
text/html.  Two scalars are returned: the rendered type (either text/html
or whatever the original type was), and the rendered text.
.ie n .IP "set_rendered($text, $type)" 4
.el .IP "set_rendered($text, \f(CW$type\fR)" 4
.IX Item "set_rendered($text, $type)"
Set the rendered text and type for the given part.  If type is not
specified, and text is a defined value, a default of 'text/plain' is used.
This can be used, for instance, to render non-text parts using plugins.
.IP "\fIvisible_rendered()\fR" 4
.IX Item "visible_rendered()"
Render and return the visible text in this part.
.IP "\fIinvisible_rendered()\fR" 4
.IX Item "invisible_rendered()"
Render and return the invisible text in this part.
.IP "\fIcontent_summary()\fR" 4
.IX Item "content_summary()"
Returns an array of scalars describing the mime parts of the message.
Note: This function requires that the message be parsed first!
.IP "\fIdelete_header()\fR" 4
.IX Item "delete_header()"
Delete the specified header (decoded and raw) from the Node information.
.IP "\fIget_header()\fR" 4
.IX Item "get_header()"
Retrieve a specific header.  Will have a newline at the end and will be
unfolded.  The first parameter is the header name (case-insensitive),
and the second parameter (optional) is whether or not to return the
raw header.
.Sp
If \fIget_header()\fR is called in an array context, an array will be returned
with each header entry in a different element.  In a scalar context,
the last specific header is returned.
.Sp
ie: If 'Subject' is specified as the header, and there are 2 Subject
headers in a message, the last/bottom one in the message is returned in
scalar context or both are returned in array context.
.Sp
Btw, returning the last header field (not the first) happens to be consistent
with \s-1DKIM\s0 signatures, which search for and cover multiple header fields
bottom-up according to the 'h' tag. Let's keep it this way.
.IP "\fIget_all_headers()\fR" 4
.IX Item "get_all_headers()"
Retrieve all headers.  Each header will have a newline at the end and
will be unfolded.  The first parameter (optional) is whether or not to
return the raw headers, and the second parameter (optional) is whether
or not to include the mbox separator.
.Sp
If \fIget_all_header()\fR is called in an array context, an array will be
returned with each header entry in a different element.  In a scalar
context, the headers are returned in a single scalar.

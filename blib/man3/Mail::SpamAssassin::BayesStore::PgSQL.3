.\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Mail::SpamAssassin::BayesStore::PgSQL 3"
.TH Mail::SpamAssassin::BayesStore::PgSQL 3 "2011-06-07" "perl v5.18.1" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Mail::SpamAssassin::BayesStore::PgSQL \- PostgreSQL Specific Bayesian Storage Module Implementation
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This module implements a PostgreSQL specific bayesian storage module.
.PP
It subclasses Mail::SpamAssassin::BayesStore::SQL and overrides any methods
which makes \s-1SQL\s0 calls involving the token column.  Since PostgreSQL uses \s-1BYTEA\s0
for the token column type you must make sure that the \s-1DBD\s0 driver does the proper
quoting.  You can accomplish this by binding the token column to a specific type.
.SH "METHODS"
.IX Header "METHODS"
.SS "token_expiration"
.IX Subsection "token_expiration"
public instance (Integer, Integer,
                 Integer, Integer) token_expiration(\e% \f(CW$opts\fR,
                                                    Integer \f(CW$newdelta\fR,
                                                    @ \f(CW@vars\fR)
.PP
Description:
This method performs the database specific expiration of tokens based on
the passed in \f(CW$newdelta\fR and \f(CW@vars\fR.
.SS "seen_put"
.IX Subsection "seen_put"
public (Boolean) seen_put (string \f(CW$msgid\fR, char \f(CW$flag\fR)
.PP
Description:
This method records \f(CW$msgid\fR as the type given by \f(CW$flag\fR.  \f(CW$flag\fR is one of
two values 's' for spam and 'h' for ham.
.SS "seen_delete"
.IX Subsection "seen_delete"
public instance (Boolean) seen_delete (string \f(CW$msgid\fR)
.PP
Description:
This method removes \f(CW$msgid\fR from the database.
.SS "set_last_expire"
.IX Subsection "set_last_expire"
public instance (Boolean) set_last_expire (Integer \f(CW$time\fR)
.PP
Description:
This method sets the last expire time.
.SS "set_running_expire_tok"
.IX Subsection "set_running_expire_tok"
public instance (String \f(CW$time\fR) set_running_expire_tok ()
.PP
Description:
This method sets the time that an expire starts running.
.SS "remove_running_expire_tok"
.IX Subsection "remove_running_expire_tok"
public instance (Boolean) remove_running_expire_tok ()
.PP
Description:
This method removes the row in the database that indicates that
and expire is currently running.
.SS "tok_get"
.IX Subsection "tok_get"
public instance (Integer, Integer, Integer) tok_get (String \f(CW$token\fR)
.PP
Description:
This method retrieves a specificed token (\f(CW$token\fR) from the database
and returns it's spam_count, ham_count and last access time.
.SS "tok_get_all"
.IX Subsection "tok_get_all"
public instance (\e@) tok_get (@ \f(CW$tokens\fR)
.PP
Description:
This method retrieves the specified tokens (\f(CW$tokens\fR) from storage and returns
an array ref of arrays spam count, ham acount and last access time.
.SS "nspam_nham_change"
.IX Subsection "nspam_nham_change"
public instance (Boolean) nspam_nham_change (Integer \f(CW$num_spam\fR,
                                             Integer \f(CW$num_ham\fR)
.PP
Description:
This method updates the number of spam and the number of ham in the database.
.SS "tok_touch"
.IX Subsection "tok_touch"
public instance (Boolean) tok_touch (String \f(CW$token\fR,
                                     String \f(CW$atime\fR)
.PP
Description:
This method updates the given tokens (\f(CW$token\fR) atime.
.PP
The assumption is that the token already exists in the database.
.SS "tok_touch_all"
.IX Subsection "tok_touch_all"
public instance (Boolean) tok_touch (\e@ \f(CW$tokens\fR
                                     String \f(CW$atime\fR)
.PP
Description:
This method does a mass update of the given list of tokens \f(CW$tokens\fR, if the existing token
atime is < \f(CW$atime\fR.
.PP
The assumption is that the tokens already exist in the database.
.PP
We should never be touching more than N_SIGNIFICANT_TOKENS, so we can make
some assumptions about how to handle the data (ie no need to batch like we
do in tok_get_all)
.SS "cleanup"
.IX Subsection "cleanup"
public instance (Boolean) cleanup ()
.PP
Description:
This method perfoms any cleanup necessary before moving onto the next
operation.
.SS "clear_database"
.IX Subsection "clear_database"
public instance (Boolean) clear_database ()
.PP
Description:
This method deletes all records for a particular user.
.PP
Callers should be aware that any errors returned by this method
could causes the database to be inconsistent for the given user.
.SH "Private Methods"
.IX Header "Private Methods"
.SS "_connect_db"
.IX Subsection "_connect_db"
private instance (Boolean) _connect_db ()
.PP
Description:
This method connects to the \s-1SQL\s0 database.
.SS "_put_token"
.IX Subsection "_put_token"
private instance (Boolean) _put_token (string \f(CW$token\fR,
                                       integer \f(CW$spam_count\fR,
                                       integer \f(CW$ham_count\fR,
				       string \f(CW$atime\fR)
.PP
Description:
This method performs the work of either inserting or updating a token in
the database.
.SS "_put_tokens"
.IX Subsection "_put_tokens"
private instance (Boolean) _put_tokens (\e% \f(CW$token\fR,
                                        integer \f(CW$spam_count\fR,
                                        integer \f(CW$ham_count\fR,
	 			        string \f(CW$atime\fR)
.PP
Description:
This method performs the work of either inserting or updating tokens in
the database.
.SS "_token_select_string"
.IX Subsection "_token_select_string"
private instance (String) _token_select_string
.PP
Description:
This method returns the string to be used in \s-1SELECT\s0 statements to represent
the token column.

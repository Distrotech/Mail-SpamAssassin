.\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Mail::SpamAssassin::Message 3"
.TH Mail::SpamAssassin::Message 3 "2011-06-07" "perl v5.18.1" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Mail::SpamAssassin::Message \- decode, render, and hold an RFC\-2822 message
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This module encapsulates an email message and allows access to the various \s-1MIME\s0
message parts and message metadata.
.PP
The message structure, after initiating a \fIparse()\fR cycle, looks like this:
.PP
.Vb 7
\&  Message object, also top\-level node in Message::Node tree
\&     |
\&     +\-\-\-> Message::Node for other parts in MIME structure
\&     |       |\-\-\-> [ more Message::Node parts ... ]
\&     |       [ others ... ]
\&     |
\&     +\-\-\-> Message::Metadata object to hold metadata
.Ve
.SH "PUBLIC METHODS"
.IX Header "PUBLIC METHODS"
.IP "\fInew()\fR" 4
.IX Item "new()"
Creates a Mail::SpamAssassin::Message object.  Takes a hash reference
as a parameter.  The used hash key/value pairs are as follows:
.Sp
\&\f(CW\*(C`message\*(C'\fR is either undef (which will use \s-1STDIN\s0), a scalar of the
entire message, an array reference of the message with 1 line per array
element, and either a file glob or IO::File object which holds the entire
contents of the message.
.Sp
Note: The message is expected to generally be in \s-1RFC 2822\s0 format, optionally
including an mbox message separator line (the \*(L"From \*(R" line) as the first line.
.Sp
\&\f(CW\*(C`parse_now\*(C'\fR specifies whether or not to create the \s-1MIME\s0 tree
at object-creation time or later as necessary.
.Sp
The \fIparse_now\fR option, by default, is set to false (0).
This allows SpamAssassin to not have to generate the tree of
Mail::SpamAssassin::Message::Node objects and their related data if the
tree is not going to be used.  This is handy, for instance, when running
\&\f(CW\*(C`spamassassin \-d\*(C'\fR, which only needs the pristine header and body which
is always handled when the object is created.
.Sp
\&\f(CW\*(C`subparse\*(C'\fR specifies how many \s-1MIME\s0 recursion levels should be parsed.
Defaults to 20.
.IP "\fIfind_parts()\fR" 4
.IX Item "find_parts()"
Used to search the tree for specific \s-1MIME\s0 parts.  See
\&\fIMail::SpamAssassin::Message::Node\fR for more details.
.IP "\fIget_pristine_header()\fR" 4
.IX Item "get_pristine_header()"
Returns pristine headers of the message.  If no specific header name
is given as a parameter (case-insensitive), then all headers will be
returned as a scalar, including the blank line at the end of the headers.
.Sp
If called in an array context, an array will be returned with each
specific header in a different element.  In a scalar context, the last
specific header is returned.
.Sp
ie: If 'Subject' is specified as the header, and there are 2 Subject
headers in a message, the last/bottom one in the message is returned in
scalar context or both are returned in array context.
.Sp
Btw, returning the last header field (not the first) happens to be consistent
with \s-1DKIM\s0 signatures, which search for and cover multiple header fields
bottom-up according to the 'h' tag. Let's keep it this way.
.Sp
Note: the returned header will include the ending newline and any embedded
whitespace folding.
.IP "\fIget_mbox_separator()\fR" 4
.IX Item "get_mbox_separator()"
Returns the mbox separator found in the message, or undef if there
wasn't one.
.IP "\fIget_body()\fR" 4
.IX Item "get_body()"
Returns an array of the pristine message body, one line per array element.
.IP "\fIget_pristine()\fR" 4
.IX Item "get_pristine()"
Returns a scalar of the entire pristine message.
.IP "\fIget_pristine_body()\fR" 4
.IX Item "get_pristine_body()"
Returns a scalar of the pristine message body.
.IP "extract_message_metadata($permsgstatus)" 4
.IX Item "extract_message_metadata($permsgstatus)"
.PD 0
.ie n .IP "$str = get_metadata($hdr)" 4
.el .IP "\f(CW$str\fR = get_metadata($hdr)" 4
.IX Item "$str = get_metadata($hdr)"
.ie n .IP "put_metadata($hdr, $text)" 4
.el .IP "put_metadata($hdr, \f(CW$text\fR)" 4
.IX Item "put_metadata($hdr, $text)"
.IP "delete_metadata($hdr)" 4
.IX Item "delete_metadata($hdr)"
.ie n .IP "$str = \fIget_all_metadata()\fR" 4
.el .IP "\f(CW$str\fR = \fIget_all_metadata()\fR" 4
.IX Item "$str = get_all_metadata()"
.IP "\fIfinish_metadata()\fR" 4
.IX Item "finish_metadata()"
.PD
Destroys the metadata for this message.  Once a message has been
scanned fully, the metadata is no longer required.   Destroying
this will free up some memory.
.IP "\fIfinish()\fR" 4
.IX Item "finish()"
Clean up an object so that it can be destroyed.
.IP "\fIreceive_date()\fR" 4
.IX Item "receive_date()"
Return a time_t value with the received date of the current message,
or current time if received time couldn't be determined.
.SH "PARSING METHODS, NON-PUBLIC"
.IX Header "PARSING METHODS, NON-PUBLIC"
These methods take a RFC2822\-esque formatted message and create a tree
with all of the \s-1MIME\s0 body parts included.  Those parts will be decoded
as necessary, and text/html parts will be rendered into a standard text
format, suitable for use in SpamAssassin.
.IP "\fIparse_body()\fR" 4
.IX Item "parse_body()"
\&\fIparse_body()\fR passes the body part that was passed in onto the
correct part parser, either \fI_parse_multipart()\fR for multipart/* parts,
or \fI_parse_normal()\fR for everything else.  Multipart sections become the
root of sub-trees, while everything else becomes a leaf in the tree.
.Sp
For multipart messages, the first call to \fIparse_body()\fR doesn't create a
new sub-tree and just uses the parent node to contain children.  All other
calls to \fIparse_body()\fR will cause a new sub-tree root to be created and
children will exist underneath that root.  (this is just so the tree
doesn't have a root node which points at the actual root node ...)
.IP "\fI_parse_multipart()\fR" 4
.IX Item "_parse_multipart()"
Generate a root node, and for each child part call \fIparse_body()\fR
to generate the tree.
.IP "\fI_parse_normal()\fR" 4
.IX Item "_parse_normal()"
Generate a leaf node and add it to the parent.
